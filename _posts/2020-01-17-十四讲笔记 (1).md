---
layout: post
title: 十四讲笔记 (1)
---

<!-- TOC -->

- [第二讲](#第二讲)
    - [2.2 经典视觉 SLAM 框架](#22-经典视觉-slam-框架)
    - [2.4 编程基础](#24-编程基础)
        - [2.4.1 使用库](#241-使用库)
- [第三讲 三维空间刚体运动](#第三讲-三维空间刚体运动)
    - [3.1 旋转矩阵](#31-旋转矩阵)
        - [3.1.1 点和向量, 坐标系](#311-点和向量-坐标系)
        - [3.1.2 坐标系之间的欧式变换](#312-坐标系之间的欧式变换)
        - [3.1.3 变换矩阵与齐次坐标](#313-变换矩阵与齐次坐标)
    - [3.2 实践: Eigen 的使用](#32-实践-eigen-的使用)
    - [3.3 旋转向量和欧拉角](#33-旋转向量和欧拉角)
        - [3.3.1 旋转向量](#331-旋转向量)
        - [3.3.2 欧拉角](#332-欧拉角)
    - [3.4 四元数](#34-四元数)
        - [3.4.1 四元数定义](#341-四元数定义)
        - [3.4.2 四元数运算](#342-四元数运算)
            - [加法和减法](#加法和减法)
            - [乘法](#乘法)
            - [共轭](#共轭)
            - [模长](#模长)
            - [逆](#逆)
            - [数乘与点乘](#数乘与点乘)
        - [3.4.3 用四元数表示旋转](#343-用四元数表示旋转)
        - [3.4.4 四元数到旋转矩阵](#344-四元数到旋转矩阵)
    - [3.5 相似, 仿射, 射影变换](#35-相似-仿射-射影变换)

<!-- /TOC -->

> 很惭愧, 终于开始看十四讲了.

# 第二讲

## 2.2 经典视觉 SLAM 框架

<center>
<img src = "https://raw.githubusercontent.com/v1otusc/PicBed/master/slam-frame.png">
</center>

## 2.4 编程基础

### 2.4.1 使用库

在一个 C++ 工程中, 只有带有 main 函数的文件才会生成可执行文件, 而另一些代码, 我们只想把它们打包成一个东西, 供其他程序调用, 这个东西叫做库.

编译成库, 在 CMakeLists.txt 中写:

```
add_library(hello libHelloSlam.cpp)
```

在 Linux 中, 库文件分成静态库和共享库两种. 静态库以 .a 作为后缀名. 共享库以 .so 结尾. 所有库都是一些函数打包后的集合, 差别在于静态库每次被调用都会生成一个副本, 而共享库则只有一个副本, 更省空间. 如果我们想生成共享库而不是静态库, 只需用:

```
add_library(hello_shared SHARED libHelloSlam.cpp)
```

**有了头文件和库文件, 就可以调用这个库了**, 然后在生成可执行文件的 CMakeLists.txt 中链接到库:

```
add_executable(useHello useHello.cpp)

target_link_library(useHello hello_shared)
```

> 带有 main 函数的源文件才能被编译为可执行文件, 其他的编译成库文件.

# 第三讲 三维空间刚体运动

## 3.1 旋转矩阵

### 3.1.1 点和向量, 坐标系

大部分程序库都使用右手坐标系.

向量的内积比较熟悉了, 用来描述向量之间的投影关系. 向量的外积以前也遇到过, 表示两个向量张成四边形的面积, 但是用到的不多, 用矩阵表示的样子也没见到过:

$$
    \boldsymbol{a} \times \boldsymbol{b} = \begin{bmatrix}
        \boldsymbol{i} & \boldsymbol{j} & \boldsymbol{k} \\
        a_1 & a_2 & a_3 \\
        b_1 & b_2 & b_3 \\
    \end{bmatrix} = \begin{bmatrix}
        a_2b_3 - a_3b_2 \\
        a_3b_1 - a_1b_3 \\
        a_1b_2 - a_2b_1
    \end{bmatrix} = \begin{bmatrix}
        0 & -a_3 & a_2 \\
        a_3 & 0 & -a_1 \\
        -a_2 & a_1 & 0 \\
    \end{bmatrix}\boldsymbol{b} = a\wedge b
$$

第 4 项是用一个[反对称矩阵](https://baike.baidu.com/item/%E5%8F%8D%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5/9063240?fr=aladdin)来表示 **a** 向量, 可以记作 **a**∧. 

### 3.1.2 坐标系之间的欧式变换

> 这部分 OpenGL 的课上讲过, 正好复习记录一下.

坐标变换指的是什么? 常见的情况是将机器人坐标系统观测到的点用世界坐标系(惯性坐标系来表示). 

相机运动是一个刚体运动, 向量在各个坐标系下的长度和夹角都不发生变化, 也就是说变换的形式仅有旋转和平移, 称作欧式变换.

对于同一向量在两个**单位正交基**下, 有对应的坐标:

$$
    [e_1, e_2, e_3]\begin{bmatrix}
        a_1 \\
        a_2 \\
        a_3
    \end{bmatrix} = 
    [e_1', e_2', e_3']\begin{bmatrix}
        a_1' \\
        a_2' \\
        a_3'
    \end{bmatrix}
$$

两边同时左乘一个:

$$
    [e_1^T, e_2^T, e_3^T]^T
$$

那么右边的系数就变成了一个单位矩阵, 变为:

$$
    \boldsymbol{a} = \begin{bmatrix}
        a_1 \\
        a_2 \\
        a_3
    \end{bmatrix} = \begin{bmatrix}
        e_1^Te_1' & e_1^Te_2'& e_1^Te_3' \\
        e_2^Te_1' & e_2^Te_2'& e_2^Te_3' \\
        e_3^Te_1' & e_3^Te_2'& e_3^Te_3'
    \end{bmatrix} \begin{bmatrix}
        a_1' \\
        a_2' \\
        a_3'
    \end{bmatrix} = R\boldsymbol{a'}
$$

可以看到 **R** 矩阵与基下的坐标是没什么关系的, 可以用来描述旋转过程本身, 称作旋转矩阵. 旋转矩阵是行列式为 1 的正交矩阵.

旋转矩阵的集合定义如下:

$$
    SO(n) = \{R\in R^{n×n} | RR^T = I, det(R) = 1\}
$$

其中, SO(n) 是特殊正交群的意思, SO(3) 就可以表示三维空间的旋转了.

欧式变换如果还有平移, 就直接再加一个向量就好了:

$$
    \boldsymbol{a} = \boldsymbol{Ra'} + \boldsymbol{t}
$$

### 3.1.3 变换矩阵与齐次坐标

如果一直采用以上变换, 形式上就会变得非常烦, 采用齐次坐标的做法就能解决这个问题:

$$
    \begin{bmatrix}
        a \\
        1
    \end{bmatrix} = \begin{bmatrix}
        R & t \\
        0^T & 1
    \end{bmatrix}\begin{bmatrix}
        a' \\
        1
    \end{bmatrix} = \boldsymbol{T}\begin{bmatrix}
        a' \\
        1
    \end{bmatrix}
$$

也就是在三维向量的末尾添加 1, 变成了四维向量, 称为齐次坐标. 其中 **T** 称作变换矩阵.

齐次坐标并不是唯一的, 某个点的分量同乘一个非零常数后, 仍表示同一个点, 但是当最后一点不为 0 时, 总是可以强制变为 1, 就得到了**唯一的非齐次坐标**.

$$
    \boldsymbol{x} = [x, y, z, w]^T = [x/w, y/w, z/w, 1]^T
$$

采用齐次坐标的方便之处在于:

$$
    \boldsymbol{b = T_1a, c = T_2b \Rightarrow c = T_2T_1a}
$$

和旋转矩阵类似, 变换矩阵的集合称作特殊欧式群, 记作:

$$
    SE(3) = \{T = \begin{bmatrix}
        R & t \\
        0^T & 1
    \end{bmatrix} R^{4×4} | R\in SO(3), t \in R^3\}
$$

求解变换矩阵的逆, 可以自己推导:

$$
    T^{-1} = \begin{bmatrix}
        R^T & -R^Tt \\
        0^T & 1
    \end{bmatrix}
$$

## 3.2 实践: Eigen 的使用

相比于其他库, Eigen 特殊之处在于, 它是一个纯用头文件搭建起来的库, 这意味着你只能找到它的头文件, 而没有 .so 或 .a 那样的二进制文件.

+ 在 Eigen 中需要指定矩阵的大小和类型.
+ 必须显式地对数据类型进行转化.
+ 若发现使用 Eigen 出错, 可以寻找错误提示中的大写部分来推测问题.

学习 Eigen -> [http://eigen.tuxfamily.org/dox-devel/modules.html](http://eigen.tuxfamily.org/dox-devel/modules.html).

## 3.3 旋转向量和欧拉角

### 3.3.1 旋转向量

为什么引入旋转向量, 至少有以下几个理由:

1. 旋转矩阵要用 9 个量描述 3 个自由度的旋转, 变换矩阵就更过分了, 要用 16 个量描述区区一个 6 个自由度, 简直是大大的浪费.
2. 两种矩阵都包括 R 阵, 这个矩阵必须是一个行列式为 1 的正交矩阵, 约束条件太严格.

最好的方法是用一个旋转向量来表示一个旋转的过程, 这个向量的方向指向转轴 **n**, 大小表示转角 θ, 那么这个旋转向量就可以表示为 θ**n**. (这不就是向量的外积吗? 太好了).

从旋转向量到旋转矩阵, 有罗德里德斯公式, 记住就行:

$$
    R = cos\theta I + (1 - cos\theta) nn^T + sin\theta n\wedge
$$

∧ 表示由一个向量到反对称矩阵的变换符.

从旋转矩阵到旋转向量, 可以根据上式推导, 有:

$$
    tr(R) = 1 - 2cos\theta
$$

关于转轴 n, 由于旋转轴上的向量在旋转后不发生改变, 说明:

$$
    Rn = n
$$

因此, **转轴 n 是矩阵 R 特征值 1 对应的特征向量. 求解此方程, 再归一化, 就得到了转轴**, 精彩, 太精彩了. 这个式子我早就应该想到了.

### 3.3.2 欧拉角

三种转角:

1. 绕物体的 Z 轴旋转, 得到偏航角 yaw;
2. 绕旋转之后的 Y 轴旋转, 得到俯仰角 pitch;
3. 绕旋转之后的 X 轴旋转, 得到滚转角 roll.

其他情况可能三种转角定义的方式不同, 要灵活处理.

欧拉角的重大缺陷, 著名的万向锁问题, 产生了奇异性:

<center>
<img src = "https://raw.githubusercontent.com/v1otusc/PicBed/master/Gimbal_Lock.png" width = 90%>
</center>

## 3.4 四元数

旋转角和欧拉角都很不错, 不冗余, 但是会遭遇到**奇异性问题**(可以理解为使系统丢失掉自由度).

在表达三维空间旋转时, 有一种类似于复数的代数: 四元数(Quaternion). 四元数是 Hamilton 找到的一种扩展的复数. 它既是紧凑的, 也没有奇异性. 如果说缺点的话, 四元数不够直观,其运算稍为复杂一些.

TODO: 2020-01-19: 这部分概念我现在实在是想不明白, 只好先把运算规则记录一下, 最好能马上遇到一个实例, 到时候再来更新一下我的理解.

### 3.4.1 四元数定义

一个四元数 q 拥有一个实部和三个虚部.

$$
    \boldsymbol{q} = q_0 + q_1i + q_2j + q_3k
$$

虚部满足关系式:

$$
    \begin{cases} 
    i^2 = j^2 = k^2 = -1\\ 
    ij = k, ji = -k \\
    jk = i, kj = -i \\
    ki = j, ik = -j
    \end{cases}
$$

用一个标量和向量来表示四元数:

$$
    \boldsymbol{q} = [s, \boldsymbol{v}], s = q_0 \in R, \boldsymbol{v} = [q_1, q_2, q_3]^T \in R^3
$$

根据实部和虚部是否为 0, 分别对应(实部为 0)虚四元数和实四元数.

假设某个旋转是绕着单位向量

$$
    n = [n_x, n_y, n_z]^T
$$

旋转 θ 角度, 旋转的四元数的表示为:

$$
    q = [cos\frac{\theta}{2}, n_xsin\frac{\theta}{2}, n_ysin\frac{\theta}{2}, n_zsin\frac{\theta}{2}]^T
$$

对上面的式子加上一个 2π, 四元数变成了 -q, 但是却表示的相同的旋转, 也就是说**在四元数中,任意的旋转都可以由两个互为相反数的四元数表示**.

### 3.4.2 四元数运算

先记住吧.

对于两个四元数 **q**<sub>a</sub>=[s<sub>a</sub>, **v**<sub>a</sub>] 和  **q**<sub>b</sub> = [s<sub>b</sub>, **v**<sub>b</sub>].

$$
    q_a = s_a + x_ai + y_aj + z_ak \quad q_b = s_b + x_bi + y_bj + z_bk
$$

#### 加法和减法

$$
    q_a ± q_b = [s_a ± s_b, v_a ± v_b] .
$$

#### 乘法

$$
    q_a q_b = s_a s_b − x_a x_b − y_a y_b − z_a z_b \\
          + (s_a x_b + x_a s_b + y_a z_b − z_a y_b ) i \\
          + (s_a y_b − x_a z_b + y_a s_b + z_a x_b ) j \\
          + (s_a z_b + x_a y_b − y_b x_a + z_a s_b ) k
$$

或者表示为:

$$
    q_a q_b = [s_a s_b - v_a^Tv_b, s_av_b + s_bv_a + v_a × v_b]^T
$$

#### 共轭

$$
    q_a^* = [s_a, -v_a]
$$

同时有:

$$
    q^*q = qq^* = [s^2 + v^Tv, 0]
$$

#### 模长

$$
    \|  q_a \| = \sqrt{s_a^2 + x_a^2 + y_a^2 + z_a^2}
$$

同时有:

$$
    \| q_a q_b \| = \| q_a \| \|q_b\|
$$

#### 逆



#### 数乘与点乘



### 3.4.3 用四元数表示旋转

首先, 把三维空间点用一个虚四元数表示:

$$
    p = [0, v]
$$

参考旋转四元数的形式:

$$
    q = [cos\frac{\theta}{2}, \boldsymbol{n}sin\frac{\theta}{2}]
$$

那么, 旋转后的 p` 可以表示为:

$$
    p' = qpq^{-1}
$$

推导一下, 实部为 0, 是一个虚四元数, 三个分量表示旋转后的 3D 坐标.



### 3.4.4 四元数到旋转矩阵



## 3.5 相似, 仿射, 射影变换


