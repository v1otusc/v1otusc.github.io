---
layout: post
title: 互斥量、锁和条件变量
---

> https://blog.csdn.net/try_again_later/article/details/104864189

- [1 lock_guard<mutex> lock\(\)](#1-lock_guardmutex-lock)
	- [1.1 直接操作mutex的lock/unlock函数](#11-直接操作mutex的lockunlock函数)
	- [1.2 使用 lock_guard/unique_lock 自动加锁、解锁](#12-使用-lock_guardunique_lock-自动加锁解锁)
	- [1.3 unique_lock 和 lock_guard 区别](#13-unique_lock-和-lock_guard-区别)
- [2 条件变量 condition_variable](#2-条件变量-condition_variable)
	- [2.1 条件变量定义](#21-条件变量定义)
	- [2.2 条件变量使用](#22-条件变量使用)

## 1 lock_guard<mutex> lock\(\)

### 1.1 直接操作mutex的lock/unlock函数

多线程访问同一资源时，为了保证数据的一致性，必要时需要加锁mutex，表示任一时刻，只能有一个线程访问该对象,加锁mutex

```c++
#include <iostream>
#include <boost>
 
std::mutex m_buf;
 
void Counter(){
   m_buf.lock();
   int i=++count;// 只有当一个线程输出完毕了，另一个线程才能输出
   m_buf.unlock();
}

int main(){
  boost::thread_group threads;// 创建进程
  for(int i=0;i<4;i++)
      threads.create_thread(&Counter);
  threads.join_all();
 return 0;
}
```

### 1.2 使用 lock_guard/unique_lock 自动加锁、解锁

类似智能指针，与 1.1 相比只需要加锁，后面无须解锁 unlock()

```c++

#include <iostream>
#include <boost/thread/lock_guard.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/thread/thread.hpp>
 
boost::mutex mutex;
int count = 0;
 
void Counter() {
  // lock_guard 在构造函数里加锁，在析构函数里解锁。
  boost::lock_guard<boost::mutex> lck(mutex);
 
  int i = ++count;
  std::cout << "count == " << i << std::endl;
}
 
int main() {
  boost::thread_group threads;
  for (int i = 0; i < 4; ++i) {
    threads.create_thread(&Counter);
  }
 
  threads.join_all();
  return 0;
}
```

`unique_lock<mutex> lck(m);` 就是创建了一个unique_lock对象lck，并将其与互斥量mutex绑定，同时对其上锁。

### 1.3 unique_lock 和 lock_guard 区别

1. unique_lock不需要始终拥有关联的mutex，而lock_guard始终拥有mutex。这意味着unique_lock需要利用owns_lock()判断是否拥有mutex。
2. unique_lock可以进行临时解锁和再上锁，如在构造对象之后使用lck.unlock()就可以进行解锁，lck.lock()进行上锁，而不必等到析构时自动解锁。
3. unique_lock还接受第二个参数来进行构造。 unique_lock<mutex> lck(m,perd)：仅仅是将lck与m绑定，不会自动进行lock()和unlock()；后面需要自己unlock()。

如果要结合使用条件变量 condition_variable，应该使用 unique_lock

## 2 条件变量 condition_variable

estimator_node.cpp 中 process() 函数最开始有个线程同步操作。

```c++
std::condition_variable con;

// 在提取 measurements 时互斥锁 m_buf 会锁住，此时无法接收数据;等待 measurements 接收数据完成就会被唤醒
std::unique_lock<std::mutex> lk(m_buf);
con.wait(lk, [&]{return (measurements = getMeasurements()).size() != 0;});
lk.unlock();
```

调用了 wait 函数，条件变量的对象 con 和互斥锁 lk 绑定，之后判断第二个参数。**wait调用后，会先释放锁 lk->unlock() ，之后进入等待状态；当其它进程调用通知激活后，会再次加锁。**

### 2.1 条件变量定义

```c++
#include "..."

using namespace std;
 
class MsgList   //模拟消息的写入和读取
{
public:
	void MsgWrite()// 写线程
	{
		for (int i = 0; i < 10000; i++)   //写入1000条消息，用i来模拟消息
		{
			lock_guard<mutex> guard(m);// 自动加锁
			msgQue.push_back(i); // 加到消息队列
			cout << "Write Message : " << i << endl;
		}
	}
 
	void MsgRead() // 读线程
	{
		while (true)    
		{
			if (!msgQue.empty())//每次都要判断消息列表中是否有消息，如果有的话就将其读出
			{
				lock_guard<mutex> guard(m);
				cout << "Read Message : " << msgQue.front() << endl; //读取最先来临的消息
				msgQue.pop_front();  //将已读消息删除
			}
			else
			{
				lock_guard<mutex> guard(m);  //这里加锁是为了保证cout输出完整
				cout << "There is no Message !" << endl;
			}
		}
	}
private:
	deque<int> msgQue;   //消息队列
	mutex m;   //互斥锁 m
};
 
int main()
{
	MsgList myMsg;
	thread ReadThread(&MsgList::MsgRead, &myMsg);  //写线程
	thread WriteThread(&MsgList::MsgWrite, &myMsg);   //读线程
	ReadThread.join();
	WriteThread.join();
 
  return 0;
}
```

上面的代码通过互斥锁实现了 msgQue 的读和写，但是读线程函数是个死循环，程序会一直循环判断消息队列是否有消息，这样就造成了CPU不必要的开销。因为程序不知道到底消息队列中有没有消息，就一直需要去判断，如果能有一个好的办法，当消息队列中有消息的时候读线程再去执行，如果队列中没有消息的话就让读线程一直阻塞住。该如何实现呢？这就是条件变量condition_variable的作用了。

```c++
class MsgList
{
public:
	void MsgWrite()// 写数据
	{
		for (int i = 0; i < 10000; i++)
		{
			unique_lock<mutex> lck(m);
			msgQue.push_back(i);
			cout << "Write Message : " << i << endl;
			mycond.notify_one();   // !唤醒wait函数
		}
	}
	void MsgRead() // 读数据
	{
		while (true)
		{
			unique_lock<mutex> lck(m);
      // 如果队列不为空才会继续向下执行
			mycond.wait(lck, [this]() {   //调用wait函数，先解锁lck，然后判断lambda的返回值
				return !msgQue.empty();
			});
			int ReadData = msgQue.front();  //执行到这里，说明msgQue非空，就可以读取数据了
			msgQue.pop_front();
			cout << "Read Message : " << ReadData << endl;
 
		}
	}
private:
	deque<int> msgQue;
	mutex m;
	condition_variable mycond; // 多了条件变量
};
 
int main()
{
	MsgList myMsg;
	thread ReadThread(&MsgList::MsgRead, &myMsg);  //写线程
	thread WriteThread(&MsgList::MsgWrite, &myMsg);   //读线程
	ReadThread.join();
	WriteThread.join();
 
  return 0;
}
```

条件变量往往需要绑定一个 unique_lock(也是互斥锁的一种实现)，当在线程中通过条件变量调用 wait 函数时，该线程就会被阻塞住，直到在另一个线程中调用 notify_one/all 函数来唤醒这个线程。需要注意，如果 lambda 函数返回的是 true，wait 函数不阻塞会直接返回，但是如果返回 false，wait 函数会被伪唤醒，继续判断函数的返回值。

### 2.2 条件变量使用

```c++
#include <iostream>
#include <mutex>
#include <thread>
#include <condition_variable>
 
std::mutex              g_mutex;     // 用到的全局锁
std::condition_variable g_cond;      // 用到的条件变量
 
int  g_i       = 0;
bool g_running = true;
 
void ThreadFunc(int n) {             // 线程执行函数
  for (int i = 0; i < n; ++i) {
    {
      std::lock_guard<std::mutex> lock(g_mutex);      // 加锁，离开{}作用域后锁释放
      ++g_i;
      std::cout << "plus g_i by func thread " << std::this_thread::get_id() << std::endl;
    }
  }
 
  std::unique_lock<std::mutex> lock(g_mutex);        // 加锁
  while (g_running) {
    std::cout << "wait for exit" << std::endl;
    g_cond.wait(lock);                               // wait调用后，会先释放锁，之后进入等待状态；当其它进程调用通知激活后，会再次加锁
  }
   // 这一步要到notify（）才会运行，线程唤醒
  std::cout << "func thread exit" << std::endl;
}
 
int main() {
  int n = 100;
  std::thread t1(ThreadFunc, n);       // 创建t1线程（func thread），t1会执行`ThreadFunc`中的指令，相当于运行到wait，剩下的要到notify()才能运行
 
  for (int i = 0; i < n; ++i) {
    {
      std::lock_guard<std::mutex> lock(g_mutex);
      ++g_i;
      std::cout << "plus g_i by main thread " << std::this_thread::get_id() << std::endl;
    }
  }
 
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    g_running = false;
    g_cond.notify_one();      // 通知其它线程
  }
 
  t1.join();         // 等待线程t1结束
 
  std::cout << "g_i = " << g_i << std::endl;

  return 0;
}
```

最终 `g_i = 200`，两个线程交替执行，需要有先后顺序时，就可以通过条件变量这种机制来做到；

